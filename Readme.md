书籍《Java设计模式》-刘伟
## 简单工厂模式

>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。  

由于 简单工厂模式中用于创建实例的方法通常都是静态方法，因此简单工厂模式又被称为静态工厂(Static Factory Method)模式，它是一种创建型模式。

### 简单工厂模式结构

1. Factory（工厂角色）：又叫做工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑。对外提供静态的工厂方法，返回值类型为抽象类类型。
2. Product（抽象产品角色）：工厂类创建的所有对象的父类，封装了各种产品对象的公有方法。
3. ConcreteProduct（具体产品角色）：简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体的实例。它需要实现抽象产品角色的抽象方法。

![image-20220329222845689](.\images\image-20220329222845689.png)

### 创建对象与使用对象

Java中通常有以下几种创建对象的方式：

* 使用new关键字直接创建对象
* 通过反射机制创建对象
* 通过克隆方法创建对象
* 通过工厂类创建对象

工厂是强调：两个类A和B之间的关系应该仅仅是A创建B或者A使用B，而不能两种关系都有。

创建和使用分离可以防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。但并不是需要为系统中的每个类都配置一个工厂类，如果一个类很简单，而且不存在太多变化，其构造过程也很简单，此时就无需为其提供工厂类，直接在使用之前实例化即可。

### 简单工厂模式优/缺点与适用环境

#### 简单工厂模式优点：

优点主要有如下：

1. 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。
2. 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度上减少使用者的记忆量。
3. 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 简单工厂模式缺点

缺点主要有如下：

1. 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。
2. 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。
3. 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
4. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

#### 简单工厂模式适用环境

在以下情况下可以考虑使用简单工厂模式：

* 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
* 客户端只知道传人工厂类的参数，对于如何创建对象并不关心。

## 工厂方法模式

工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的缺陷，更好的符合开闭原则的要求，在增加新的具体产品对象时不需要对已有的系统做任何修改。

### 工厂方法模式概述

简单工厂模式如果要新增一个具体的产品需要修改工厂类的代码，这在一定程度上违反了开闭原则。在工厂方法模式中不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。

工厂方法模式的定义：

> 定义一个用于创建对象的接口，但是让子类决定将哪个类实例化。工厂方法模式让一个类的实例化延迟到其子类。

工厂方法模式简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式是一种类创建型模型。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象，这样做的目的是将产品类的实例化延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

### 工厂方法模式结构与实现

#### 工厂方法模式结构

工厂方法模式的结构如图：

![image-20220330124911882](.\images\image-20220330124911882.png)

工厂方法模式包含4个角色：

1. **Product（抽象产品）：**它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
2. **ConcreteProduct（具体产品）：**它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品直接一一对应。
3. **Factory（抽象工厂）：**在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
4. **ConcreteFactory(具体工厂)：**它是抽象工厂类的子类，它实现了在抽象工厂中申明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

#### 工厂方法模式实现

与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。

典型代码如下：

```java
public interface Factory{
    public Product factoryMethod();
}
```

具体对象的创建由工厂子类负责，客户端针对抽象工厂编程，可在运行时指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。

```java
public class ConcreteFactory implement Factory{
    @Override
    public Product factoryMethod(){
        return new ConcreteProduct();
    }
}
```

典型的客户端代码如：

```java
		……
		Factory factory = new ConcreteFactory(); 
		// 通过配置文件与反射机制实现
		// Factory factory = (Factory) XMLUtil.getBean("concreteProduct");
        Product product = factory.factoryMethod();
        product.someMethod();
		……
```

### 工厂方法模式应用实例

具体参考项目代码：`factory-method-pattern`

### 工厂方法模式的重载

在某些情况下，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。但是对于同一个具体工厂而言，无论使用哪个工厂方法，所创建的产品类型均要相同。重载的工厂方法结构图如下：

![image-20220330140550674](.\images\image-20220330140550674.png)

在抽象工厂中声明了多个重载的工厂方法，在具体工厂中实现这些工厂方法，这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。

### 工厂方法的隐藏

有时候为了简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中国的业务方法。

![image-20220330141224301](.\images\image-20220330141224301.png)

`LoggerFactory`代码修改如下：

```java
public interface LoggerFactory {
    /**
     * 创建日志
     * @return 日志抽象类
     */
    public Logger createLogger();

    /**
     * 在工厂中实现写日志的逻辑
     */
    public default void writeLog(){
        Logger logger = this.createLogger();
        logger.writeLog();
    }
}
```

客户端代码：

```java
public class Client {
    public static void main(String[] args) {
        // 此处注意bean.xml配置文件中的class中配置的具体类以免出错。
        LoggerFactory factory = (LoggerFactory) XMLUtil.getBean("fileLogger");
        //此处直接用过工厂调用，而不是具体的客户端
        factory.writeLog();
    }
}
```

### 工厂方法模式优/缺点与使用环境

#### 工厂方法模式优点：

1. 工厂方法用来创建客户所需的产品，同时还向客户隐藏哪种具体产品类将被实例化这一细节，用户只需要关系所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。
2. 可以让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部，工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。
3. 在系统中加入新产品时无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，而只需要添加一个具体的工厂和工具产品即可，这样系统的可扩展性也就变得非常好，完全符合开闭原则。

#### 工厂方法模式缺点

1. 在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
2. 由于考虑到扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。

#### 工厂方法模式适用环境

在以下情况可以考虑使用工厂方法模式：

1. 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。
2. 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。